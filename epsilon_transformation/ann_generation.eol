/*
  This file implements the ANNController denotational semantic rules, avaliable here: https://github.com/UoY-RoboStar/ann-circus-rules

  This relies on 'boolean_query.eol', Fang Yan's implementation of the RC to Circus M2M translation. 

  We will import, a minimal version of boolean_query, Fang's RC to Circus rules, not all of it, because it is very big. 

  Author: Ziggy Attala
*/

//import "boolean_query.eol";
import "RoboChart2Circus_M2M.eol";
import "RoboChart2Circus_M2MExtension.eol";

//This creates AnglePIDANN ANNController manually, as the RoboChart Model Exporter, to a .model file in EMF, is not functional yet. 
//Treat, the Z declaration, Value == \real, as part of the toolkit, as part of the import. 

/*
Parsing
Slowdown, not in the creating channels, or name lists, or names, and it is fine with old version. 

It is some change, just to the expressions, but not FloatExp. Applied expressions, or ref exprs, or createing channel declarations. 

*/

var anglepidann = RC!ANNController.all().at(0);
anglepidann.annSemantics();


//We need to wrap this in a Z Section. Name "AnglePIDANN"
//Or, whatever the name of the 

//We now need to return the paragraphs, we have generated. 

/*
operation createZSect(
	sect_name: String,
	paraSeq: Sequence<Z!Para>,
	parentNameSeq: Sequence<String>
	): Z!ZSect{

sect_name, the paraSeq, and the parent name, we don't need that for the 
We don't need this, at all, parentNameSeq, for the Isabelle transformation. 

But good to have it. 

Z!ZSect. 

Z section, to get to a Spec. 

operation createSpec(zsect: Z!ZSect): Z!Spec{

narrative secction, spec sections. 

NarativeSection is just blank, that is correct. 

First, get the Collator working. 


*/





//RULE 1: Implementation of [c : ANNController]_ANN : Program, top-level rule.
operation RC!ANNController annSemantics() : Z!Spec {
  //Returns a Z Spec. 
  
  var channelPars = self.ANNChannelDecl();
  var annProc = self.ANNProc();
  
  channelPars.add(annProc);
  
  
  var zSect = createZSect("AnglePIDANN", channelPars, Sequence{"roboworld_2d_toolkit_withval"});
  return createSpec(zSect);
  
  
  
}

//RULE 2: Function ANNChannelDecl().
operation RC!ANNController ANNChannelDecl() : Sequence<Z!ZPara> {

  //The index of the last layer, -1 because 0-indexed. 
  var lastLayerI = self.layerNo()-1;
  //lastLayerS, as an integer, by taking the value attribute of the IntegerExp.
  var lastLayerS = self.annparameters.layerstructure.values.at(lastLayerI).value;
  
  var annChannels = self.ANNChannels(self.layerNo(), lastLayerS, Sequence{});
  
  //declare terminate channel
  var terminateChannel = Set{"terminate"}.createChannelPara("");
  
  //Implementation of set comprehension, using nested collect method in EOL.
  var hiddenEvtsNames = Set{1..(self.layerNo()-1)}.collect(l | Set{1..l}.collect(n | layerRes(l, n)));
  var hiddenEvtsNamesFlat = hiddenEvtsNames.flatten().asSet();
  var hiddenEvts = createChannelSet(createBasicChannelSetExpr(hiddenEvtsNamesFlat));
  
  var hiddenEvtsChanSet = hiddenEvts.createChanSetPara("ANNHiddenEvts");
  
  annChannels.add(terminateChannel);
  annChannels.add(hiddenEvtsChanSet);
  
  return annChannels;
  
}

//RULE 3: Function ANNChannels
operation RC!ANNController ANNChannels(l : Integer, n : Integer, seq : Sequence<Z!Para>) : Sequence<Z!Para> {
  l.println();
  n.println();
  "".println();
  if((l == 0) and (n == 1)) {
    var chanPar = Set{layerRes(l, n)}.createChannelPara("", "Value");
    seq.add(chanPar);
    return seq;
  }
  else {
    var chanPar = Set{layerRes(l, n)}.createChannelPara("", "Value");
    
    if(l != 0) {
      seq.addAll(NodeOutChannels(l, n, self.LStructure((l-1)), Sequence{}));
    }
      
    if(n > 1) {
      seq.add(chanPar);
      return self.ANNChannels(l, (n-1), seq);
    }
    else {
      seq.add(chanPar);
      return self.ANNChannels((l-1), self.LStructure((l-1)), seq);
    }
  }
}

//RULE 4: Function NodeOutChannels.
operation NodeOutChannels(l : Integer, n : Integer, i : Integer, seq : Sequence<Z!Para>) : Sequence<Z!Para> {
  if(i == 1) {
    seq.add(Set{nodeOut(l, n, i)}.createChannelPara("", "Value"));
    return seq;
  }
  else {
    seq.add(Set{nodeOut(l, n, i)}.createChannelPara("", "Value"));
    return NodeOutChannels(l, n, (i-1), seq);
  
  }
}

//RULE 5: ANNProc
operation RC!ANNController ANNProc() : Z!ProcessPara {
  //We need to create a SEQUENCE of Z paragraphs, which are the paras of the paraList. 
  //for the createBasicProcess(mainActionName: String) where create the Call Action, ANNRenamed. 
  //needs to be of type Z!Para, 
  /*
    lower levels, Action_Para, 

    createActionPara(), makes an ActionPara, which is a type of Para. 

   need a Z!CircusAction, 

  createAction2(
	type: String, 
	fst_action: Z!CircusAction, 
	snd_action: Z!CircusAction
	):
  this is, "InterruptAction", "SeqAction", or "ExtChoiceAction". 

  createParallelProcess(
	cs_name: String, 
	left: Z!CircusProcess, 
	right: Z!CircusProcess
	):Z!ParallelProcess

    Parameterised action, Param_Action, 

There is NO param_action, creation, that Fang has made, it is Z!ParamAction. 

Then we need Extch Action, 

External choice action, 

The class is Z!ExtChoiceAction. It is an Action2. 

This function, 
operation Sequence<Z!CircusAction> createSequenceAsExtchoiceAction(): Z!ExtChoiceAction

Automatically creates nested external choices, we can use this, sequence of Z!CircusActions. 

Decl_List. 

  Fang also has: 
operation Sequence<Z!CircusAction> createSequenceAsSeqAction(): Z!SeqAction

  Parameterised action, it is an ActionD, action with a list of declarations. 

Action1, unary action, has a ZDeclList, 0-1, ZDeclList.decls, declaration, which is a Term. 

Action1, just has a .circusAction, which is just a Z!CircusAction. 

no decl, A Decl is JUST a Term. 

a Term is ANYTHING. 

Declaration, 

Var_Decl, with type, ref_expr, to natural numbers, and name_list, a list of names, of just l, n, i, 

operation String createZName(): Z!ZName{

String context, createZName(), 

Create name list: 
operation createNameList(stringSet: Set<String>): Z!ZNameList{



VarDeclCommand, 

VarDecl, is a Decl, with an expression, and a ZNameList, 

Then need RefExpr, 

createRefExpr:
operation String createRefExpr(explicit: Boolean, mixFix: Boolean): Z!RefExpr{

false, false, usually. if the reference expression is mix fit. 




    
  */
  
  //Let's create the basicProcess, don't need to return anything, just need to create the write processes. 
  
  //create the basic process first. 
  
  //It's to text, not to model, why its different. 
  
  //need to create 
  
  //each action, 
  
  //sequence of Z Paras, each one is the actionpara, is an
  
  //Each is an ActionPara. 
  
  //Each, of the collator, etc, rules, returns an actionpara. 
  
  //Try to create a basic process, 
  
  //Main action name, is ANNRenamed
  
  var mainAction = "ANNRenamed";
  
  var collatorPar = self.Collator();
  
  
  var annProcFull = Sequence{collatorPar}.createBasicProcess(mainAction);
  
  return annProcFull.createProcessPara("AnglePIDANN", true);
  
  
}

//RULE 6: Function Collator
operation RC!ANNController Collator() : Z!ActionPara {
  //replicated external choice, 
  //createsequenceasextchoice, is what we need, mixed with collecting, 
  
  //collecting into a single expression, which is a 
  //needs to be gathered into a createsequecneasseq
  
  //for l 1 to ayerno, 
  //collatorActions is a sequence, of CircusActions, which we feed into, 
  //need to fix this. start with just
  var collatorActions = Sequence{1..(self.layerNo())}.collect(l | 
  	Sequence{1..(self.LStructure(l))}.collect(n | 
  		Sequence{0..self.LStructure(l-1)}.collect(i | 
  			self.CollatorExp(l, n, i)))); 
  			
  /*var collatorActions = Set{1..(self.layerNo())}.collect(l |
  	 Set{1..(self.LStructure(l))}.collect(n | 
  	 	Set{1..(self.LStructure((l-1))}.collect(i |
  	 		CollatorExp(l, n, i)) )));*/
  	 		
  
  //Not it, we need this to be a param action. 
  
  //var collatorAction = collatorActions.flatten().asSequence().createSequenceAsExtChoiceAction();
  
  //var collatorParamAction = 
  	 		
  //return collatorParamAction.createActionPara("Collator");
  
  //Just need to replace this with the list of external choice. 
  //collatorExp, next stage, is jus tthe 
  
  
  var basicAction = collatorActions.flatten().asSequence().createSequenceAsExtchoiceAction();
    
  var varList1 = createVarDecl(Set{"l, n, i"}, "int");
  var varList2 = createVarDecl(Set{"sum"}, "Value");
  
  var declList = Set{varList1, varList2}.createDeclList();
  
  var paramProcess = basicAction.createParamAction(declList);
  
  var collatorActionPar = paramProcess.createActionPara("Collator");
  
  return collatorActionPar;
  
}

//create guard, as "l = l", "n = n", "i = i", and returns it. 
operation createGuard(l, n, i : Integer) : Z!Pred {
  //num equality pred. 
  //create the reference expressions, l, n, and i. 
  var lPred = createNumEqualityPred("l".createRefExpr(false, false), l);
  var nPred = createNumEqualityPred("n".createRefExpr(false, false), n);
  var iPred = createNumEqualityPred("i".createRefExpr(false, false), i);
  
  return Sequence{lPred, nPred, iPred}.createSequenceAsAndPred();
}

//Additional rule:
operation RC!ANNController CollatorExp(l, n, i : Integer) : Z!CircusAction {
  if(i == 0) {
    
     var sumRef = "sum".createRefExpr(false, false);
	 var bias = self.bias(l, n).createFloatExpr();
	  
	 var sumExp = createPlusExpr(sumRef, bias);
	  
	 var reluExp = createReluExpr(sumExp);
	  
	 var layerResEvent = createOutputCommunication(layerRes(l, n), reluExp); 
	  
	 var prefixAction = createPrefixingAction(layerResEvent, createSkipAction());
	 
	 var guardedAction = createGuardedAction(createGuard(l, n, i), prefixAction);
	 
	 return guardedAction;
	 
  } else {
     var nodeOutEvent = createInputCommunication(nodeOut(l, n, i), "x");
     
     var lExpr = "l".createRefExpr(false, false);
     var nExpr = "n".createRefExpr(false, false);
     var i1Expr = createMinusExpr("i".createRefExpr(false, false), 1.createNumExpr());
     
     var plusExpr = createPlusExpr("sum".createRefExpr(false, false), "x".createRefExpr(false, false));
     
     var collatorArgs = Sequence{lExpr, nExpr, i1Expr, plusExpr};
     
     var callEvent = "Collator".createCallAction(collatorArgs);
     
     var prefixAction = createPrefixingAction(nodeOutEvent, callEvent);
     
     var guardedAction = createGuardedAction(createGuard(l, n, i), prefixAction);
     
     return guardedAction;
  }
   
}

//RULE 13: 
operation RC!ANNController LStructure(i : Integer) : Integer {
  if(i == 0) {
    return self.annparameters.inputContext.allEvents().size();
  }
  else {
    //0 indexing. 
    return self.annparameters.layerstructure.values.at(i-1).value;
  }
}

//RULE 14: layerRes Channel. Has to be a string, because of how channels are created.
operation layerRes(l : Integer, n : Integer) : String {
  return "layerRes" + l + "" + n;
}
//RULE 16: nodeOut Channel. 
operation nodeOut(l : Integer, n : Integer, i : Integer) : String {
  return "nodeOut" + l + "" + n + "" + i;
}

//RULE 17: Function layerNo.
operation RC!ANNController layerNo() : Integer {
  var layerstructure = self.annparameters.layerstructure;
  var lSize = layerstructure.values.size();
  return lSize;
}

//RULE 18: Function weight
operation RC!ANNController weight(l, n, i : Integer) : Real {
  var layerindex = self.annparameters.weights.values.at(l-1);
  var nodeindex = layerindex.values.at(n-1);
  var index = nodeindex.values.at(i-1);
  return index.negExtract();
}

//RULE 19: Function bias
operation RC!ANNController bias(l, n : Integer) : Real {
  var layerindex = self.annparameters.biases.values.at(l-1);
  var node = layerindex.values.at(n-1);
  return node.negExtract();
}

//Helper rule: Neg extraction: 
operation RC!Expression negExtract() : Real {
  if(self.isTypeOf(RC!Neg)) {
    return -(self.exp.value);
  }
  else {
    return self.value;
  }
}


//Only translation rules we should need are the floating point expressions, and events, and channels. 

//Do channels first. 
//make operations. 
//useful operations: 
//createFloatExpr() : Z!Expr, context type, is RC!FloatExp
//operation Sequence<Z!Para> createBasicProcess(mainActionName: String): Z!BasicProcess{
//