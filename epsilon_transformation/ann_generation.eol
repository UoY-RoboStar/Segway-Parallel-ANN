/*
  This file implements the ANNController denotational semantic rules, avaliable here: https://github.com/UoY-RoboStar/ann-circus-rules

  This relies on 'boolean_query.eol', Fang Yan's implementation of the RC to Circus M2M translation. 

  We will import, a minimal version of boolean_query, Fang's RC to Circus rules, not all of it, because it is very big. 

  Author: Ziggy Attala
*/

//import "boolean_query.eol";
import "RoboChart2Circus_M2M.eol";
import "RoboChart2Circus_M2MExtension.eol";

var anglepidann = RC!ANNController.all().at(0);
anglepidann.annSemantics();


//RULE 1: Implementation of [c : ANNController]_ANN : Program, top-level rule, returns a Z!Spec.
operation RC!ANNController annSemantics() : Z!Spec {
  
  var channelPars = self.ANNChannelDecl();
  var annProc = self.ANNProc();
  
  channelPars.add(annProc);
  
  var zSect = createZSect("AnglePIDANN", channelPars, Sequence{"roboworld_2d_toolkit_withval"});
  return createSpec(zSect);
  
}

//RULE 2: Function ANNChannelDecl().
operation RC!ANNController ANNChannelDecl() : Sequence<Z!ZPara> {

  //The index of the last layer, -1 because 0-indexed. 
  var lastLayerI = self.layerNo()-1;
  //lastLayerS, as an integer, by taking the value attribute of the IntegerExp.
  var lastLayerS = self.annparameters.layerstructure.values.at(lastLayerI).value;
  
  var annChannels = self.ANNChannels(self.layerNo(), lastLayerS, Sequence{});
  
  //declare terminate channel
  var terminateChannel = Set{"terminate"}.createChannelPara("");
  
  //Implementation of set comprehension, using nested collect method in EOL.
  var hiddenEvtsNames = Set{1..(self.layerNo()-1)}.collect(l | Set{1..l}.collect(n | layerRes(l, n)));
  var hiddenEvtsNamesFlat = hiddenEvtsNames.flatten().asSet();
  var hiddenEvts = createChannelSet(createBasicChannelSetExpr(hiddenEvtsNamesFlat));
  
  var hiddenEvtsChanSet = hiddenEvts.createChanSetPara("ANNHiddenEvts");
  
  annChannels.add(terminateChannel);
  annChannels.add(hiddenEvtsChanSet);
  
  return annChannels;
  
}

//RULE 3: Function ANNChannels
operation RC!ANNController ANNChannels(l : Integer, n : Integer, seq : Sequence<Z!Para>) : Sequence<Z!Para> {
  l.println();
  n.println();
  "".println();
  if((l == 0) and (n == 1)) {
    var chanPar = Set{layerRes(l, n)}.createChannelPara("", "Value");
    seq.add(chanPar);
    return seq;
  }
  else {
    var chanPar = Set{layerRes(l, n)}.createChannelPara("", "Value");
    
    if(l != 0) {
      seq.addAll(NodeOutChannels(l, n, self.LStructure((l-1)), Sequence{}));
    }
      
    if(n > 1) {
      seq.add(chanPar);
      return self.ANNChannels(l, (n-1), seq);
    }
    else {
      seq.add(chanPar);
      return self.ANNChannels((l-1), self.LStructure((l-1)), seq);
    }
  }
}

//RULE 4: Function NodeOutChannels.
operation NodeOutChannels(l : Integer, n : Integer, i : Integer, seq : Sequence<Z!Para>) : Sequence<Z!Para> {
  if(i == 1) {
    seq.add(Set{nodeOut(l, n, i)}.createChannelPara("", "Value"));
    return seq;
  }
  else {
    seq.add(Set{nodeOut(l, n, i)}.createChannelPara("", "Value"));
    return NodeOutChannels(l, n, (i-1), seq);
  
  }
}

//RULE 5: ANNProc
operation RC!ANNController ANNProc() : Z!ProcessPara {
  //We need to create a SEQUENCE of Z paragraphs, which are the paras of the paraList. 
  //for the createBasicProcess(mainActionName: String) where create the Call Action, ANNRenamed. 
  //needs to be of type Z!Para, 
  /*
    lower levels, Action_Para, 

    createActionPara(), makes an ActionPara, which is a type of Para. 

   need a Z!CircusAction, 

  createAction2(
	type: String, 
	fst_action: Z!CircusAction, 
	snd_action: Z!CircusAction
	):
  this is, "InterruptAction", "SeqAction", or "ExtChoiceAction". 

  createParallelProcess(
	cs_name: String, 
	left: Z!CircusProcess, 
	right: Z!CircusProcess
	):Z!ParallelProcess

    Parameterised action, Param_Action, 

There is NO param_action, creation, that Fang has made, it is Z!ParamAction. 

Then we need Extch Action, 

External choice action, 

The class is Z!ExtChoiceAction. It is an Action2. 

This function, 
operation Sequence<Z!CircusAction> createSequenceAsExtchoiceAction(): Z!ExtChoiceAction

Automatically creates nested external choices, we can use this, sequence of Z!CircusActions. 

Decl_List. 

  Fang also has: 
operation Sequence<Z!CircusAction> createSequenceAsSeqAction(): Z!SeqAction

  Parameterised action, it is an ActionD, action with a list of declarations. 

Action1, unary action, has a ZDeclList, 0-1, ZDeclList.decls, declaration, which is a Term. 

Action1, just has a .circusAction, which is just a Z!CircusAction. 

no decl, A Decl is JUST a Term. 

a Term is ANYTHING. 

Declaration, 

Var_Decl, with type, ref_expr, to natural numbers, and name_list, a list of names, of just l, n, i, 

operation String createZName(): Z!ZName{

String context, createZName(), 

Create name list: 
operation createNameList(stringSet: Set<String>): Z!ZNameList{



VarDeclCommand, 

VarDecl, is a Decl, with an expression, and a ZNameList, 

Then need RefExpr, 

createRefExpr:
operation String createRefExpr(explicit: Boolean, mixFix: Boolean): Z!RefExpr{

false, false, usually. if the reference expression is mix fit. 




    
  */
  
  var mainAction = "ANNRenamed";
  
  var collatorPar = self.Collator();
  
  var annProcFull = Sequence{collatorPar}.createBasicProcess(mainAction);
  
  return annProcFull.createProcessPara("AnglePIDANN", true);
  
}

//RULE 6: Function Collator
operation RC!ANNController Collator() : Z!ActionPara {
  var collatorActions = Sequence{1..(self.layerNo())}.collect(l | 
  	Sequence{1..(self.LStructure(l))}.collect(n | 
  		Sequence{0..self.LStructure(l-1)}.collect(i | 
  			self.CollatorExp(l, n, i)))); 
  
  var basicAction = collatorActions.flatten().asSequence().createSequenceAsExtchoiceAction();
    
  var varList1 = createVarDecl(Set{"l, n, i"}, "int");
  var varList2 = createVarDecl(Set{"sum"}, "Value");
  
  var declList = Set{varList1, varList2}.createDeclList();
  
  var paramProcess = basicAction.createParamAction(declList);
  
  var collatorActionPar = paramProcess.createActionPara("Collator");
  
  return collatorActionPar;
  
}

//create guard, as "l = l", "n = n", "i = i", and returns it. 
operation createGuard(l, n, i : Integer) : Z!Pred {
  //num equality pred. 
  //create the reference expressions, l, n, and i. 
  var lPred = createNumEqualityPred("l".createRefExpr(false, false), l);
  var nPred = createNumEqualityPred("n".createRefExpr(false, false), n);
  var iPred = createNumEqualityPred("i".createRefExpr(false, false), i);
  
  return Sequence{lPred, nPred, iPred}.createSequenceAsAndPred();
}

//Additional rule:
operation RC!ANNController CollatorExp(l, n, i : Integer) : Z!CircusAction {
  if(i == 0) {
    
     var sumRef = "sum".createRefExpr(false, false);
	 var bias = self.bias(l, n).createFloatExpr();
	  
	 var sumExp = createPlusExpr(sumRef, bias);
	  
	 var reluExp = createReluExpr(sumExp);
	  
	 var layerResEvent = createOutputCommunication(layerRes(l, n), reluExp); 
	  
	 var prefixAction = createPrefixingAction(layerResEvent, createSkipAction());
	 
	 var guardedAction = createGuardedAction(createGuard(l, n, i), prefixAction);
	 
	 return guardedAction;
	 
  } else {
     var nodeOutEvent = createInputCommunication(nodeOut(l, n, i), "x");
     
     var lExpr = "l".createRefExpr(false, false);
     var nExpr = "n".createRefExpr(false, false);
     var i1Expr = createMinusExpr("i".createRefExpr(false, false), 1.createNumExpr());
     
     var plusExpr = createPlusExpr("sum".createRefExpr(false, false), "x".createRefExpr(false, false));
     
     var collatorArgs = Sequence{lExpr, nExpr, i1Expr, plusExpr};
     
     var callEvent = "Collator".createCallAction(collatorArgs);
     
     var prefixAction = createPrefixingAction(nodeOutEvent, callEvent);
     
     var guardedAction = createGuardedAction(createGuard(l, n, i), prefixAction);
     
     return guardedAction;
  }
   
}



//RULE 13: 
operation RC!ANNController LStructure(i : Integer) : Integer {
  if(i == 0) {
    return self.annparameters.inputContext.allEvents().size();
  }
  else {
    //0 indexing. 
    return self.annparameters.layerstructure.values.at(i-1).value;
  }
}

//RULE 14: layerRes Channel. Has to be a string, because of how channels are created.
operation layerRes(l : Integer, n : Integer) : String {
  return "layerRes" + l + "" + n;
}
//RULE 16: nodeOut Channel. 
operation nodeOut(l : Integer, n : Integer, i : Integer) : String {
  return "nodeOut" + l + "" + n + "" + i;
}

//RULE 17: Function layerNo.
operation RC!ANNController layerNo() : Integer {
  var layerstructure = self.annparameters.layerstructure;
  var lSize = layerstructure.values.size();
  return lSize;
}

//RULE 18: Function weight
operation RC!ANNController weight(l, n, i : Integer) : Real {
  var layerindex = self.annparameters.weights.values.at(l-1);
  var nodeindex = layerindex.values.at(n-1);
  var index = nodeindex.values.at(i-1);
  return index.negExtract();
}

//RULE 19: Function bias
operation RC!ANNController bias(l, n : Integer) : Real {
  var layerindex = self.annparameters.biases.values.at(l-1);
  var node = layerindex.values.at(n-1);
  return node.negExtract();
}