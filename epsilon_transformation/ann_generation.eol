/*
  This file implements the ANNController denotational semantic rules, avaliable here: https://github.com/UoY-RoboStar/ann-circus-rules

  This relies on 'boolean_query.eol', Fang Yan's implementation of the RC to Circus M2M translation. 

  We will import, a minimal version of boolean_query, Fang's RC to Circus rules, not all of it, because it is very big. 

  Author: Ziggy Attala
*/

//import "boolean_query.eol";
import "RoboChart2Circus_M2M.eol";
import "RoboChart2Circus_M2MExtension.eol";

//RC!ANNController.all().at(0).println();

var ann = RC!ANNController.all().at(0);
//ann.annSemantics();

ann.IndexedLayerRes(0);
ann.AllNodeOut();
ann.IndexedNodeOut(1, 1);
ann.IndexedNodeOut(2, 1);

//RULE 1: Implementation of [c : ANNController]_ANN : Program, top-level rule, returns a Z!Spec.
operation RC!ANNController annSemantics() : Z!Spec {
  var channelPars = self.ANNChannelDecl();
  var annProc = self.ANNProc();
  
  channelPars.add(annProc);
  
  var zSect = createZSect(self.name, channelPars, Sequence{"roboworld_2d_toolkit_withval"});
  return createSpec(zSect);
  
}

//RULE 2: Function ANNChannelDecl().
operation RC!ANNController ANNChannelDecl() : Sequence<Z!ZPara> {

  //The index of the last layer, -1 because 0-indexed. 
  var lastLayerI = self.layerNo()-1;
  //lastLayerS, as an integer, by taking the value attribute of the IntegerExp.
  var lastLayerS = self.annparameters.layerstructure.values.at(lastLayerI).value;
  
  var annChannels = self.ANNChannels(self.layerNo(), lastLayerS, Sequence{});
  
  //declare terminate channel
  var terminateChannel = Set{"terminate"}.createChannelPara("terminate");
  
  //Implementation of set comprehension, using nested collect method in EOL.
  var hiddenEvtsNames = Set{1..(self.layerNo()-1)}.collect(l | Set{1..l}.collect(n | layerRes(l, n)));
  var hiddenEvtsNamesFlat = hiddenEvtsNames.flatten().asSet();
  var hiddenEvts = createChannelSet(createBasicChannelSetExpr(hiddenEvtsNamesFlat));
  
  var hiddenEvtsChanSet = hiddenEvts.createChanSetPara("ANNHiddenEvts");
  
  annChannels.add(terminateChannel);
  annChannels.add(hiddenEvtsChanSet);
  
  return annChannels;
  
}

//RULE 3: Function ANNChannels
operation RC!ANNController ANNChannels(l : Integer, n : Integer, seq : Sequence<Z!Para>) : Sequence<Z!Para> {
  if((l == 0) and (n == 1)) {
    var chanPar = Set{layerRes(l, n)}.createChannelPara(layerRes(l, n), "real");
    seq.add(chanPar);
    return seq;
  }
  else {
    var chanPar = Set{layerRes(l, n)}.createChannelPara(layerRes(l,n), "real");
    
    if(l != 0) {
      seq.addAll(NodeOutChannels(l, n, self.LStructure((l-1)), Sequence{}));
    }
      
    if(n > 1) {
      seq.add(chanPar);
      return self.ANNChannels(l, (n-1), seq);
    }
    else {
      seq.add(chanPar);
      return self.ANNChannels((l-1), self.LStructure((l-1)), seq);
    }
  }
}

//RULE 4: Function NodeOutChannels.
operation NodeOutChannels(l : Integer, n : Integer, i : Integer, seq : Sequence<Z!Para>) : Sequence<Z!Para> {
  if(i == 1) {
    seq.add(Set{nodeOut(l, n, i)}.createChannelPara(nodeOut(l,n,i), "real"));
    return seq;
  }
  else {
    seq.add(Set{nodeOut(l, n, i)}.createChannelPara(nodeOut(l,n,i), "real"));
    return NodeOutChannels(l, n, (i-1), seq);
  
  }
}

//RULE 5: ANNProc
operation RC!ANNController ANNProc() : Z!ProcessPara {
  //We need to create a SEQUENCE of Z paragraphs, which are the paras of the paraList. 
  //for the createBasicProcess(mainActionName: String) where create the Call Action, ANNRenamed. 
  //needs to be of type Z!Para, 
  /*
    lower levels, Action_Para, 

    createActionPara(), makes an ActionPara, which is a type of Para. 

   need a Z!CircusAction, 

  createAction2(
	type: String, 
	fst_action: Z!CircusAction, 
	snd_action: Z!CircusAction
	):
  this is, "InterruptAction", "SeqAction", or "ExtChoiceAction". 

  createParallelProcess(
	cs_name: String, 
	left: Z!CircusProcess, 
	right: Z!CircusProcess
	):Z!ParallelProcess

    Parameterised action, Param_Action, 

There is NO param_action, creation, that Fang has made, it is Z!ParamAction. 

Then we need Extch Action, 

External choice action, 

The class is Z!ExtChoiceAction. It is an Action2. 

This function, 
operation Sequence<Z!CircusAction> createSequenceAsExtchoiceAction(): Z!ExtChoiceAction

Automatically creates nested external choices, we can use this, sequence of Z!CircusActions. 

Decl_List. 

  Fang also has: 
operation Sequence<Z!CircusAction> createSequenceAsSeqAction(): Z!SeqAction

  Parameterised action, it is an ActionD, action with a list of declarations. 
    
  */
  
  var mainAction = "ANNRenamed";
  
  var collatorPar = self.Collator();
  var nodeInPar = self.NodeIn();
  var nodePar = self.Node();
  
  var annProcFull = Sequence{collatorPar, nodeInPar, nodePar}.createBasicProcess(mainAction);
  
  return annProcFull.createProcessPara("AnglePIDANN", true);
  
}

//RULE 6: Function Collator
operation RC!ANNController Collator() : Z!ActionPara {
  var collatorActions = Sequence{1..(self.layerNo())}.collect(l | 
  	Sequence{1..(self.LStructure(l))}.collect(n | 
  		Sequence{0..self.LStructure(l-1)}.collect(i | 
  			self.CollatorExp(l, n, i)))); 
  
  var basicAction = collatorActions.flatten().asSequence().createSequenceAsExtchoiceAction();
    
  var varList1 = createVarDecl(Set{"l, n, i"}, "int");
  var varList2 = createVarDecl(Set{"sum"}, "real");
  
  var declList = Set{varList1, varList2}.createDeclList();
  
  var paramProcess = basicAction.createParamAction(declList);
  
  var collatorActionPar = paramProcess.createActionPara("Collator");
  
  return collatorActionPar;
  
}

//Rule 7: Function NodeIn
operation RC!ANNController NodeIn() : Z!ActionPara {
   var nodeInActions = Sequence{1..(self.layerNo())}.collect(l | 
  	Sequence{1..(self.LStructure(l))}.collect(n | 
  		Sequence{1..self.LStructure(l-1)}.collect(i | 
  			self.NodeInExp(l, n, i)))); 
  
  var basicAction = nodeInActions.flatten().asSequence().createSequenceAsExtchoiceAction();
    
  var varList = createVarDecl(Set{"l, n, i"}, "int");
  
  var declList = Set{varList}.createDeclList();
  
  var paramProcess = basicAction.createParamAction(declList);
  
  var nodeInActionPar = paramProcess.createActionPara("NodeIn");
  
  return nodeInActionPar;
}

//Rule 8: Function Node
operation RC!ANNController Node() : Z!ActionPara {
   var nodeActions = Sequence{1..(self.layerNo())}.collect(l | 
  		Sequence{1..(self.LStructure(l))}.collect(n | 
  			self.NodeExp())); 
  
  var basicAction = nodeActions.flatten().asSequence().createSequenceAsExtchoiceAction();
    
  var varList = createVarDecl(Set{"l, n, inpSize"}, "int");
  
  var declList = Set{varList}.createDeclList();
  
  var paramProcess = basicAction.createParamAction(declList);
  
  var nodePar = paramProcess.createActionPara("Node");
  
  return nodePar;
}
//Node Helper Rule:
operation RC!ANNController NodeExp() : Z!CircusAction {

   /*
  InterleaveActionIdx is ActionD, 
Action with a declaration, with a declaration list. 
abstract class ActionD extends Action1 {
	val ZDeclList declList;

abstract class Action1 extends CircusAction {
	val CircusAction circusAction;


//Has a nameset, which is, 
abstract class ParActionIte extends ActionIte {
	val NameSet nameSet;

NameSet, is EMPTY, for interleaving, it is the name of the variables. for stateful behaviour. 

It is for stateful behaviour, we never have anything for the namesets. 

i, then the expression, is the ".." function, just a function from 1 to insize. 

class AlphabetisedParallelActionIte extends ParActionIte {
	val ChannelSet channelSet;
}

class InterleaveActionIte extends ParActionIte {
}
Channelsets, none, so we just need decllist, 

class ParallelActionIte extends ParActionIte {
	val ChannelSet channelSet;
}

To create channel sets, 



*/

  
   var nodeInArgs = Sequence{"l".createRefExpr(false, false), "n".createRefExpr(false, false), "i".createRefExpr(false, false)};
     
   var nodeInCall = "NodeIn".createCallAction(nodeInArgs);
     
  var varList = createVarDecl(Set{"i"}, createUpToExpr(1.createNumExpr(), "inpSize".createRefExpr(false, false)));
  
  var declList = Set{varList}.createDeclList();
  
  var iteActionTest = createInterleaveIteAction(nodeInCall, declList); 
  
  //Parallel action, with the nameset, of 
  
  return iteActionTest;
}

//RULE 13: 
operation RC!ANNController LStructure(i : Integer) : Integer {
  if(i == 0) {
    return self.annparameters.inputContext.allEvents().size();
  }
  else {
    //0 indexing. 
    return self.annparameters.layerstructure.values.at(i-1).value;
  }
}

//RULE 14: layerRes Channel. Has to be a string, because of how channels are created.
operation layerRes(l : Integer, n : Integer) : String {
  return "layerRes" + l + "" + n;
}

//RULE 15: Function IndexedLayerRes.
operation RC!ANNController IndexedLayerRes(l : Integer) : Z!CircusChannelSet {
  var channelNames =  Set{1..(self.LStructure(l))}.collect(n | 
  		layerRes(l, n));
  var basicCSExp = createBasicChannelSetExpr(channelNames.asSet());
  var channelSet = createChannelSet(basicCSExp);
  return channelSet;
}

//RULE 16: nodeOut Channel. 
operation nodeOut(l : Integer, n : Integer, i : Integer) : String {
  return "nodeOut" + l + "" + n + "" + i;
}

//RULE 17: Function layerNo.
operation RC!ANNController layerNo() : Integer {
  var layerstructure = self.annparameters.layerstructure;
  var lSize = layerstructure.values.size();
  return lSize;
}

//RULE 18: Function weight
operation RC!ANNController weight(l, n, i : Integer) : Real {
  var layerindex = self.annparameters.weights.values.at(l-1);
  var nodeindex = layerindex.values.at(n-1);
  var index = nodeindex.values.at(i-1);
  return index.negExtract();
}

//RULE 19: Function bias
operation RC!ANNController bias(l, n : Integer) : Real {
  var layerindex = self.annparameters.biases.values.at(l-1);
  var node = layerindex.values.at(n-1);
  return node.negExtract();
}

//RULE 20: Function AllNodeOut.
operation RC!ANNController AllNodeOut() : Z!CircusChannelSet {
  var channelNames = Set{1..(self.layerNo())}.collect(l | 
        Set{1..(self.LStructure(l))}.collect(n | 
          Set{1..(self.LStructure(l-1))}.collect(i | 
            nodeOut(l, n, i))));
  var basicCSExp = createBasicChannelSetExpr(channelNames.flatten().asSet());
  var channelSet = createChannelSet(basicCSExp);
  return channelSet;
}

//RULE 21: Function IndexedNodeOut
operation RC!ANNController IndexedNodeOut(l, n : Integer) : Z!CircusChannelSet {
  var channelNames = Set{1..(self.LStructure(l-1))}.collect(i | 
            nodeOut(l, n, i));
  var basicCSExp = createBasicChannelSetExpr(channelNames.flatten().asSet());
  var channelSet = createChannelSet(basicCSExp);
  return channelSet;
}


//HELPER RULES: Not in semantic rules, but helpers to implement the semantic rules: 


//NodeIn Helper Rule:
operation RC!ANNController NodeInExp(l, n, i : Integer) : Z!CircusAction {

     var layerResEvent = createInputCommunication(layerRes(l, n), "x");
     
     var xExpr = "x".createRefExpr(false, false);
     
     var weight = self.weight(l, n, i).createFloatExpr();
      
     var nodeOutVal = createMultExpr(xExpr, weight);
     
     var nodeOutEvent = createOutputCommunication(nodeOut(l, n, i), nodeOutVal);
     
     //Have to make nested prefixes backwards. 
     
     var prefixActionEnd = createPrefixingAction(nodeOutEvent, createSkipAction());
     
     var prefixAction = createPrefixingAction(layerResEvent, prefixActionEnd);
     
     var guardedAction = createGuardedAction(createGuard(l, n, i), prefixAction);
     
     return guardedAction;
   
}

//Guard creation helper.
operation createGuard(l, n, i : Integer) : Z!Pred {
  //num equality pred. 
  //create the reference expressions, l, n, and i. 
  var lPred = createNumEqualityPred("l".createRefExpr(false, false), l);
  var nPred = createNumEqualityPred("n".createRefExpr(false, false), n);
  var iPred = createNumEqualityPred("i".createRefExpr(false, false), i);
  
  return Sequence{lPred, nPred, iPred}.createSequenceAsAndPred();
}

operation RC!ANNController CollatorExp(l, n, i : Integer) : Z!CircusAction {
  if(i == 0) {
    
     var sumRef = "sum".createRefExpr(false, false);
	 var bias = self.bias(l, n).createFloatExpr();
	  
	 var sumExp = createPlusExpr(sumRef, bias);
	  
	 var reluExp = createReluExpr(sumExp);
	  
	 var layerResEvent = createOutputCommunication(layerRes(l, n), reluExp); 
	  
	 var prefixAction = createPrefixingAction(layerResEvent, createSkipAction());
	 
	 var guardedAction = createGuardedAction(createGuard(l, n, i), prefixAction);
	 
	 return guardedAction;
	 
  } else {
     var nodeOutEvent = createInputCommunication(nodeOut(l, n, i), "x");
     
     var lExpr = "l".createRefExpr(false, false);
     var nExpr = "n".createRefExpr(false, false);
     var i1Expr = createMinusExpr("i".createRefExpr(false, false), 1.createNumExpr());
     
     var plusExpr = createPlusExpr("sum".createRefExpr(false, false), "x".createRefExpr(false, false));
     
     var collatorArgs = Sequence{lExpr, nExpr, i1Expr, plusExpr};
     
     var callEvent = "Collator".createCallAction(collatorArgs);
     
     var prefixAction = createPrefixingAction(nodeOutEvent, callEvent);
     
     var guardedAction = createGuardedAction(createGuard(l, n, i), prefixAction);
     
     return guardedAction;
  }
   
}