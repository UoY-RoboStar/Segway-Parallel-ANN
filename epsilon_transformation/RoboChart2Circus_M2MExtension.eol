
//******************RULES AND HELPERS NOT FROM OUR RULES*******************/

//ADDITIONAL: Need a way of creating Paramerised Actions, Z!ParamAction


operation Z!CircusAction createParamAction(declList : Z!ZDeclList) : Z!ParamAction {
  var paramAction = new Z!ParamAction;
  paramAction.declList = declList;
  paramAction.circusAction = self;
  return paramAction;
}

operation Set<Z!VarDecl> createDeclList() : Z!ZDeclList {
  var declList = new Z!ZDeclList; 
  declList.decls.addAll(self);
  return declList;
}


//Creates a VarDecl, using a reference expression to the string type, and a ZNameList formed out of the set of strings namelist. 
operation createVarDecl(nameList : Set<String>, type : String) : Z!VarDecl {
  var varDecl = new Z!VarDecl;
  varDecl.expr = type.createRefExpr(false, false);
  varDecl.nameList = createNameList(nameList);
  
  return varDecl;
}

//Always creates an output field, cannot create a sync communication. Does not take a type, 
operation createOutputCommunication(
	chan_name: String,
	expr:Z!Expr
	): Z!Communication{
	
	var commu = new Z!Communication;

	commu.commUsage = Z!CommUsage#Normal;
	commu.indexed = false;
	commu.multiSych = 0;
	commu.channelExpr = chan_name.createRefExpr(false, false);

	commu.fieldList = new Z!CircusFieldList; 
		
	
	commu.commPattern = Z!CommPattern#Output;		
	var field = new Z!DotField;
	field.expr = expr;
		
    field.outputField = true;
	
	commu.fieldList.fields = Sequence{field};
	
	return commu;
}

//Modified, so it takes an arbritrary Z Expression, for the operands, and an arbritrary string for an operator.
operation createApplExpr(operator: String, operandLeft: Z!Expr, operandRight: Z!Expr): Z!ApplExpr{
	var expr = new Z!ApplExpr;
	//left expression, and right expression, 
	//we just need a left and right, 
	expr.mixFix = true; //CZT: C.6.21 (Function Operator Application). For example: S + T.

	expr.leftExpr = operator.createRefExpr(false, false);
	expr.rightExpr = Sequence{operandLeft, operandRight}.createTupleExpr();	
//	var left = operator.createRefExpr(false,false);
//	var right = Sequence{operand_left, operand_right}.createTupleExpr();	

//	expr.exprList = new Z!ZExprList;
//	expr.exprList.exprs = Sequence{left, right};
	
	return 	expr;
}

operation createUnaryApplExpr(operator: String, operand : Z!Expr): Z!ApplExpr{

	var expr = new Z!ApplExpr;
	expr.mixFix = true;
	
	expr.leftExpr = operator.createRefExpr(false,false);
	expr.rightExpr = operand;
	
	return 	expr;
}

//Expressions, created from EOL Built-in types.
operation Integer createNumExpr(): Z!NumExpr {
  var numExpr = new Z!NumExpr;
  numExpr.numeral = new Z!ZNumeral;
  numExpr.numeral.value = self;

  return numExpr;
}

operation Real createFloatExpr(): Z!RefExpr{
	var floatExpr = new Z!RefExpr;
	floatExpr.mixFix = false;
	floatExpr.explicit = false;
	floatExpr.name = new Z!ZName;
	floatExpr.name.word = self.asString();
		
	return floatExpr;
}


operation createPlusExpr(operandLeft: Z!Expr, operandRight: Z!Expr) : Z!ApplExpr {
  return createApplExpr("_+_", operandLeft, operandRight);
}

operation createMinusExpr(operandLeft: Z!Expr, operandRight: Z!Expr) : Z!ApplExpr {
  return createApplExpr("_-_", operandLeft, operandRight);
}

operation createMultExpr(operandLeft: Z!Expr, operandRight: Z!Expr) : Z!ApplExpr {
  return createApplExpr("_*_", operandLeft, operandRight);
}

//This is a unary expression, made in this way, as a, relu_+_, that is the way CZT parsed it.
//Parsed as binary, between the operator, and the relu ref expression. 
operation createReluExpr(operator: Z!Expr) : Z!ApplExpr {
 return createUnaryApplExpr("relu", operator);
}

//Equality predicate.
//Create an arbritrary predicate equality between two expressions. 
//equality between an expression and a number. 
//create an equality pred between an expression and an arbritrary number. 
operation createNumEqualityPred(left: Z!Expr, right: Integer): Z!MemPred{
	var pred =  new Z!MemPred;
	pred.leftExpr = left;
	
	pred.rightExpr = Set{right}.createNumSetExpr();
	//Equality, so mixFix = true. 
	pred.mixFix = true;
	
	return pred;
}

//General create set expression from set. 
//This creates sets of numbers. 
operation Set<Integer> createNumSetExpr(): Z!SetExpr{
	var setExpr = new Z!SetExpr;
	var exprList = new Z!ZExprList;
	var exprs = new Sequence<Z!Expr>;
	
	for(m in self){
		exprs.add(m.createNumExpr());
	}
	exprList.exprs = exprs;
	setExpr.exprList = exprList;
	return setExpr;
}

//Have a method to create AndPreds. 

//Arbritrary nesting. 

/****Predicate Methods*****/
//Pred2, left and right pred, 
operation createAndPred(left: Z!Pred, right: Z!Pred) : Z!AndPred {
  //and type is WEDGE always, not semicolon, or chain, so and attribute always = 3. 
  var andPred = new Z!AndPred;
  //andPred.and = And#WEDGE; should set this, but not sure if it matters, and cannot as and is a reserved word.
  andPred.leftPred = left;
  andPred.rightPred = right;
  
  return andPred;
  
}

//for a set of predicates, create a chain of and preds. They have to be different, each pred.
operation Sequence<Z!Pred> createSequenceAsAndPred(): Z!AndPred{
	var andPred;
	var size = self.size();
	var i = 0;
	andPred = createAndPred(self.at(0), self.at(1));
	i = i + 2;
	if(size > 2){
		while(i<size){
			andPred = createAndPred(andPred, self.at(i));
			i = i + 1;
		}
	}
	return andPred;
}





//EOL Expression to Z Expression. 
/*
operation RC!Plus createPlusExpr():Z!ApplExpr{
	return self.createApplExpr("_+_");
}


operation Any createApplExpr(operator: String): Z!ApplExpr{
	var expr = new Z!ApplExpr;
	expr.mixFix = true; //CZT: C.6.21 (Function Operator Application). For example: S + T.
	
	var operand_left = self.left.createExpr();
	var operand_right = self.right.createExpr();

	expr.leftExpr = operator.createRefExpr(false,false);

	expr.rightExpr = Sequence{operand_left, operand_right}.createTupleExpr();	
//	var left = operator.createRefExpr(false,false);
//	var right = Sequence{operand_left, operand_right}.createTupleExpr();	

//	expr.exprList = new Z!ZExprList;
//	expr.exprList.exprs = Sequence{left, right};
	
	return 	expr;
}


*/

//what should it take, between two variables. 

//operator is: "_+_"


//ADDITIONAL: Rule 4, of the robochart reference manual

operation RC!Context allEvents() : Set<RC!Event> {
  var selfEvents = self.events;
  var interfaceEvents = self.interfaces.collect(i | i.events);
  selfEvents.addAll(interfaceEvents.flatten().asSet());
  return selfEvents; 
}

//Helper rule: Neg extraction: 
operation RC!Expression negExtract() : Real {
  if(self.isTypeOf(RC!Neg)) {
    return -(self.exp.value);
  }
  else {
    return self.value;
  }
}
